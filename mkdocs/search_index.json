{
    "docs": [
        {
            "location": "/", 
            "text": "Oddworks SDK for Android\n\n\nDocument version: February 3, 2016\n\nSDK Version: beta-1.0.0\n\n\nThe Oddworks SDK for Android is a wrapper for the Odd Networks...\n\n\nFeatures\n\n\nThe Oddworks SDK for Android supports the following features:\n\n\n\n\nA wrapper for the Odd API that parses returned JSON into Java Objects\n\n\nA data store for objects received from the API\n\n\nA way to post metrics back to the API\n\n\n\n\nIntended Audience\n\n\nThis guide assumes that you have the necessary Java and Android development skills to work successfully with Oddworks for Android. You should know how to build and compile Android applications using Android Studio and the latest tools from the Android Developers Kit.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#oddworks-sdk-for-android", 
            "text": "Document version: February 3, 2016 \nSDK Version: beta-1.0.0  The Oddworks SDK for Android is a wrapper for the Odd Networks...", 
            "title": "Oddworks SDK for Android"
        }, 
        {
            "location": "/#features", 
            "text": "The Oddworks SDK for Android supports the following features:   A wrapper for the Odd API that parses returned JSON into Java Objects  A data store for objects received from the API  A way to post metrics back to the API", 
            "title": "Features"
        }, 
        {
            "location": "/#intended-audience", 
            "text": "This guide assumes that you have the necessary Java and Android development skills to work successfully with Oddworks for Android. You should know how to build and compile Android applications using Android Studio and the latest tools from the Android Developers Kit.", 
            "title": "Intended Audience"
        }, 
        {
            "location": "/overview/", 
            "text": "About Oddworks\n\n\nOddworks is, at its core, a Video Management System (VMS). It provides a central location to organize media and configure the devices that serve it.\n\n\nOddworks Entities\n\n\nOddworks has a handful of specific entity types that are used in concert to construct media applications. No matter which Online Video Provider (OVP) is used to provide media to Oddworks, the data will be massaged into one of these standardized objects. Our thought is that consumer applications should not need to change when adding a new OVP or changing where a video is stored.\n\n\nconfig\n\n\nThe \nconfig\n entity will contain device-specific configuration data.\n\n\nvideo and liveStream\n\n\nThe \nvideo\n and \nliveStream\n entities are the media objects that are the meat and potatoes of Odd Networks. If the media being served is a linear or live stream, it will be of type \nliveStream\n. If the media is an on-demand stream then it will be of type \nvideo\n.\n\n\npromotion\n\n\nThe \npromotion\n entity is an object that is essentially the same as a \nvideo\n or \nliveStream\n without the stream.\n\n\ncollection\n\n\nA \ncollection\n entity is an object that contains other entities.\n\n\nview\n\n\nA \nview\n entity is an object that can contain other entities through user-defined custom relationships.", 
            "title": "Oddworks Overview"
        }, 
        {
            "location": "/overview/#about-oddworks", 
            "text": "Oddworks is, at its core, a Video Management System (VMS). It provides a central location to organize media and configure the devices that serve it.", 
            "title": "About Oddworks"
        }, 
        {
            "location": "/overview/#oddworks-entities", 
            "text": "Oddworks has a handful of specific entity types that are used in concert to construct media applications. No matter which Online Video Provider (OVP) is used to provide media to Oddworks, the data will be massaged into one of these standardized objects. Our thought is that consumer applications should not need to change when adding a new OVP or changing where a video is stored.", 
            "title": "Oddworks Entities"
        }, 
        {
            "location": "/overview/#config", 
            "text": "The  config  entity will contain device-specific configuration data.", 
            "title": "config"
        }, 
        {
            "location": "/overview/#video-and-livestream", 
            "text": "The  video  and  liveStream  entities are the media objects that are the meat and potatoes of Odd Networks. If the media being served is a linear or live stream, it will be of type  liveStream . If the media is an on-demand stream then it will be of type  video .", 
            "title": "video and liveStream"
        }, 
        {
            "location": "/overview/#promotion", 
            "text": "The  promotion  entity is an object that is essentially the same as a  video  or  liveStream  without the stream.", 
            "title": "promotion"
        }, 
        {
            "location": "/overview/#collection", 
            "text": "A  collection  entity is an object that contains other entities.", 
            "title": "collection"
        }, 
        {
            "location": "/overview/#view", 
            "text": "A  view  entity is an object that can contain other entities through user-defined custom relationships.", 
            "title": "view"
        }, 
        {
            "location": "/setup/", 
            "text": "Integrate the Oddworks SDK\n\n\nOur SDK is built and hosted via \nJitpack\n. Include Jitpack at the end of the \nrepositories\n section of the app module's \nbuild.gradle\n file:\n\n\n// app/build.gradle\n\nrepositories {\n    // ...\n    maven { url \"https://jitpack.io\" }\n}\n\n\n\nNow at the end of the  \ndependencies\n section of the app module's \nbuild.gradle\n file add the Oddworks SDK:\n\n\n// app/build.gradle\n\ndependencies {\n    // ...\n    compile \"com.github.oddnetworks:OddWorksDeviceSDK:beta-1.0.0\"\n}\n\n\n\nThere's one more thing you'll need to add to this \nbuild.gradle\n file that will be used in the next step. The SDK expects an app version when it's being initialized. To create this app version we'll use Git.\n\n\n// app/build.gradle\n\nandroid {\n    // ...\n    defaultConfig {\n        // ...\n        resValue \"string\", \"git_revision\", gitRevision()\n    }\n    // ...\n}\n\n// ...\n\ndef gitRevision() {\n    def cmd = \"git rev-parse --short HEAD\"\n    return cmd.execute().text.trim()\n}\n\n\n\nSync your project with Gradle files and you will have the OddworksDeviceSDK added to your External Libraries.\n\n\nConfigure Your Access Token\n\n\nThe SDK also will need an access token to use when accessing the API. For instructions on how to receive your own access token check out our \nAPI Guide\n. For this guide we'll use a sample access token which accesses NASA content. Create a file in \napp/res/values/\n called \nsdk_strings.xml\n.\n\n\n?xml version=\"1.0\" encoding=\"utf-8\"?\n\n\nresources\n\n    \nstring name=\"x_access_token\"\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ2ZXJzaW9uIjoxLCJkZXZpY2VJRCI6IjBhODFjNmEwLWJiYjUtMTFlNS05ZWY4LWNiYmI0OWM4OTI1NiIsInNjb3BlIjpbImRldmljZSJdLCJpYXQiOjE0NTI4ODIxOTR9.iM26knCfqoPggNMeEUgH6_sW1kpwqmE9Hrso02g4LyQ\n/string\n\n\n/resources\n\n\n\n\nBe sure to add this to your \n.gitignore\n in your own project. This access token should be super secret and not kept in version control. Anybody with access to it will also be able to access your data.", 
            "title": "Library and Project Setup"
        }, 
        {
            "location": "/setup/#integrate-the-oddworks-sdk", 
            "text": "Our SDK is built and hosted via  Jitpack . Include Jitpack at the end of the  repositories  section of the app module's  build.gradle  file:  // app/build.gradle\n\nrepositories {\n    // ...\n    maven { url \"https://jitpack.io\" }\n}  Now at the end of the   dependencies  section of the app module's  build.gradle  file add the Oddworks SDK:  // app/build.gradle\n\ndependencies {\n    // ...\n    compile \"com.github.oddnetworks:OddWorksDeviceSDK:beta-1.0.0\"\n}  There's one more thing you'll need to add to this  build.gradle  file that will be used in the next step. The SDK expects an app version when it's being initialized. To create this app version we'll use Git.  // app/build.gradle\n\nandroid {\n    // ...\n    defaultConfig {\n        // ...\n        resValue \"string\", \"git_revision\", gitRevision()\n    }\n    // ...\n}\n\n// ...\n\ndef gitRevision() {\n    def cmd = \"git rev-parse --short HEAD\"\n    return cmd.execute().text.trim()\n}  Sync your project with Gradle files and you will have the OddworksDeviceSDK added to your External Libraries.", 
            "title": "Integrate the Oddworks SDK"
        }, 
        {
            "location": "/setup/#configure-your-access-token", 
            "text": "The SDK also will need an access token to use when accessing the API. For instructions on how to receive your own access token check out our  API Guide . For this guide we'll use a sample access token which accesses NASA content. Create a file in  app/res/values/  called  sdk_strings.xml .  ?xml version=\"1.0\" encoding=\"utf-8\"?  resources \n     string name=\"x_access_token\" eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ2ZXJzaW9uIjoxLCJkZXZpY2VJRCI6IjBhODFjNmEwLWJiYjUtMTFlNS05ZWY4LWNiYmI0OWM4OTI1NiIsInNjb3BlIjpbImRldmljZSJdLCJpYXQiOjE0NTI4ODIxOTR9.iM26knCfqoPggNMeEUgH6_sW1kpwqmE9Hrso02g4LyQ /string  /resources   Be sure to add this to your  .gitignore  in your own project. This access token should be super secret and not kept in version control. Anybody with access to it will also be able to access your data.", 
            "title": "Configure Your Access Token"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Application Activity and Android Manifest\n\n\nWe want to extend the \nApplication\n class so that we can handle global state. Create a new Java class in your app's main package naming it whatever you like, we'll call ours \nOddApp\n. This will be a singleton class so we'll configure it as such:\n\n\npackage sample.oddworks.com.myoddworksapplication;\n\nimport android.app.Application;\n\nimport io.oddworks.device.model.OddView;\nimport io.oddworks.device.request.RestServiceProvider;\nimport io.oddworks.device.service.OddStore;\n\npublic class OddApp extends Application {\n    private static OddApp singleton;\n    public static OddApp getInstance() {\n        return singleton;\n    }\n\n    private OddView homeView;\n    private OddView menuView;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        singleton = this;\n\n        RestServiceProvider.init(getApplicationContext(),\n                getString(R.string.x_access_token),\n                getString(R.string.git_revision));\n    }\n\n    public OddView getHomeView() {\n        return homeView;\n    }\n\n    public void setHomeView(OddView homeView) {\n        OddStore.getInstance().storeObjects(homeView.getIncluded());\n        this.homeView = homeView;\n    }\n\n    public OddView getMenuView() {\n        return menuView;\n    }\n\n    public void setMenuView(OddView menuView) {\n        OddStore.getInstance().storeObjects(menuView.getIncluded());\n        this.menuView = menuView;\n    }\n}\n\n\n\nWe've finally written the first code that interacts with the SDK. You'll notice we utilize the \nOddView\n, \nRestServiceProvider\n, and \nOddStore\n classes. The \nOddView\n class is the main way large amounts of data are passed from the SDK to the app. We have a view that represents all of the data needed to construct a dynamic menu/navigation called \nmenuView\n and one for all of the content shown on application load called \nhomeView\n. The \nRestServiceProvider\n initializes everything we need in order to interact with the API. In the setter methods for each view we're utilizing the \nOddStore\n so that we can minimize API calls if the \nhomeView\n and \nmenuView\n variables get released from memory.\n\n\nIn our \nAndroidManifest\n file we'll add this new class by adding it as the name attribute to the opening \napplication\n tag. By placing this attribute in the XML \nOddApp\n will run when the app first initializes.\n\n\napplication\n    android:name=\".OddApp\"\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:supportsRtl=\"true\"\n    android:theme=\"@style/AppTheme\" \n\n\n/application\n\n\n\n\nLauncher Activity\n\n\nWe need an Activity to handle fetching initial data from the API when the application is first launched. We'll create a new Empty Activity called \nSplashActivity\n with a corresponding \nactivity_splash\n layout file, making sure to check the \"Launcher Activity\" option. Make sure to add an attribute to this Activity in the \nAndroidManifest\n that disables it from history:\n\n\nactivity\n    android:name=\".SplashActivity\"\n    android:noHistory=\"true\"\nadd\n    \nintent-filter\n\n        \naction android:name=\"android.intent.action.MAIN\" /\n\n\n        \ncategory android:name=\"android.intent.category.LAUNCHER\" /\n\n    \n/intent-filter\n\n\n/activity", 
            "title": "Configuring your App"
        }, 
        {
            "location": "/getting_started/#application-activity-and-android-manifest", 
            "text": "We want to extend the  Application  class so that we can handle global state. Create a new Java class in your app's main package naming it whatever you like, we'll call ours  OddApp . This will be a singleton class so we'll configure it as such:  package sample.oddworks.com.myoddworksapplication;\n\nimport android.app.Application;\n\nimport io.oddworks.device.model.OddView;\nimport io.oddworks.device.request.RestServiceProvider;\nimport io.oddworks.device.service.OddStore;\n\npublic class OddApp extends Application {\n    private static OddApp singleton;\n    public static OddApp getInstance() {\n        return singleton;\n    }\n\n    private OddView homeView;\n    private OddView menuView;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        singleton = this;\n\n        RestServiceProvider.init(getApplicationContext(),\n                getString(R.string.x_access_token),\n                getString(R.string.git_revision));\n    }\n\n    public OddView getHomeView() {\n        return homeView;\n    }\n\n    public void setHomeView(OddView homeView) {\n        OddStore.getInstance().storeObjects(homeView.getIncluded());\n        this.homeView = homeView;\n    }\n\n    public OddView getMenuView() {\n        return menuView;\n    }\n\n    public void setMenuView(OddView menuView) {\n        OddStore.getInstance().storeObjects(menuView.getIncluded());\n        this.menuView = menuView;\n    }\n}  We've finally written the first code that interacts with the SDK. You'll notice we utilize the  OddView ,  RestServiceProvider , and  OddStore  classes. The  OddView  class is the main way large amounts of data are passed from the SDK to the app. We have a view that represents all of the data needed to construct a dynamic menu/navigation called  menuView  and one for all of the content shown on application load called  homeView . The  RestServiceProvider  initializes everything we need in order to interact with the API. In the setter methods for each view we're utilizing the  OddStore  so that we can minimize API calls if the  homeView  and  menuView  variables get released from memory.  In our  AndroidManifest  file we'll add this new class by adding it as the name attribute to the opening  application  tag. By placing this attribute in the XML  OddApp  will run when the app first initializes.  application\n    android:name=\".OddApp\"\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:supportsRtl=\"true\"\n    android:theme=\"@style/AppTheme\"   /application", 
            "title": "Application Activity and Android Manifest"
        }, 
        {
            "location": "/getting_started/#launcher-activity", 
            "text": "We need an Activity to handle fetching initial data from the API when the application is first launched. We'll create a new Empty Activity called  SplashActivity  with a corresponding  activity_splash  layout file, making sure to check the \"Launcher Activity\" option. Make sure to add an attribute to this Activity in the  AndroidManifest  that disables it from history:  activity\n    android:name=\".SplashActivity\"\n    android:noHistory=\"true\" add\n     intent-filter \n         action android:name=\"android.intent.action.MAIN\" / \n\n         category android:name=\"android.intent.category.LAUNCHER\" / \n     /intent-filter  /activity", 
            "title": "Launcher Activity"
        }, 
        {
            "location": "/initialize_api_calls/", 
            "text": "Get Config Data from API\n\n\nNow it's time to make our \nSplashActivity\n actually do somthing. First we'll set up the member variables...\n\n\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\npublic class SplashActivity extends AppCompatActivity {\n    // Constants\n    private static final String HOME_VIEW = \"homepage\";\n    private static final String MENU_VIEW = \"menu\";\n\n    // Data\n    private RestServiceProvider restServiceProvider = RestServiceProvider.getInstance();\n    private ApiCaller apiCaller = restServiceProvider.getApiCaller();\n\n    // ...\n}\n\n\n\nThere's a new class that we're interacting with called \nApiCaller\n. This does exactly what it sounds like and is the class used to make calls to the API.\n\n\nThe first thing we'll want to do in our \nonCreate\n method after setting the content view is set our context.\n\n\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;\n}\n// ...\n\n\n\nThe next thing check to see if the application is connected to the internet. This method may be useful in other classes in our application so instead of creating a method for it in our \nSplashActivity\n we'll create a \nUtility\n class with a method to check if there is internet connectivity.\n\n\npackage sample.oddworks.com.myoddworksapplication;\n\nimport android.content.Context;\nimport android.net.ConnectivityManager;\n\npublic class Utility {\n    public static boolean hasInternetConnection(Context context) {\n        ConnectivityManager con_manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n\n        if (con_manager.getActiveNetworkInfo() != null \n con_manager.getActiveNetworkInfo().isAvailable() \n con_manager.getActiveNetworkInfo().isConnected()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n\nIn order for this to work, we'll need to add some permissions to our \nAndroidManifest\n file right before the opening \napplication\n tag.\n\n\n// app/manifests/AndroidManifest.xml\n\n// ...\n\nuses-permission android:name=\"android.permission.INTERNET\" /\n\n\nuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\n\n// ...\n\n\n\nNow we can check to see if the app has connectivity in the \nSplashActivity\n's \nonCreate\n method:\n\n\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;\n\n    if (Utility.hasInternetConnection(getApplicationContext())) {\n        apiCaller.getConfig(new ConfigRequestCallback());\n    } else {\n        // handle failure by notifying user on UI\n        // consider giving them a \"retry\" button\n    }\n}\n\nprivate final class ConfigRequestCallback implements OddCallback\nConfig\n {\n    @Override\n    public void onSuccess(Config config) {\n        // handle success\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n}\n// ...\n\n\n\nIf the app is connected to the internet we use the \napiCaller\n to request configuration from the API and pass it a callback class that implements an \nOddCallback\n. If there's a failure we should notify the user of this and give them the option to retry. \nWarning: if you try to manipulate the UI within this callback you will crash the application since you aren't running on the main thread. You must specify that you'd like to run on the main thread if you'd like to make any UI updates.\n\n\nGetting View Data from API\n\n\nAssuming the config request returns successful we can use the config object to set up many things about our app. For now, we'll only focus on the views that the config sends us.\n\n\n// app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\nprivate final class ConfigRequestCallback implements OddCallback\nConfig\n {\n    @Override\n    public void onSuccess(Config config) {\n        Map\nString, String\n views = config.getViews();\n        String homeView = views.get(HOME_VIEW);\n        String menuView = views.get(MENU_VIEW);\n\n        apiCaller.getView(homeView, new ViewRequestCallback(HOME_VIEW));\n        apiCaller.getView(menuView, new ViewRequestCallback(MENU_VIEW));\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n}\n\nprivate final class ViewRequestCallback implements OddCallback\nOddView\n {\n    private String mViewType;\n\n    public ViewRequestCallback(String viewType) {\n        mViewType = viewType;\n    }\n\n    @Override\n    public void onSuccess(OddView view) {\n        OddApp oddApp = OddApp.getInstance();\n\n        if (getViewType().equals(HOME_VIEW)) {\n            oddApp.setHomeView(view);\n        } else if (getViewType().equals(MENU_VIEW)) {\n            oddApp.setMenuView(view);\n        }\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n\n    public String getViewType() {\n        return mViewType;\n    }\n}\n// ...\n\n\n\nHere, we're creating a new \nOddCallback\n for the views that we're requesting through the \napiCaller\n. This callback accepts a \nviewType\n parameter that will determine which view we're setting in our \nOddApp\n instance. Remember, the setter metods for each view utilize the \nOddStore\n so we'll have access to this information throughout the app if the member variables in \nOddApp\n get leaked from memory.\n\n\nThe last thing we need to do in our \nSplashActivity\n is launch a new Activity that will make use of all the data we've fetched. First we'll need to create a new Activity, we'll call ours \nHomeActivity\n. Now in the \nViewRequestCallback\n section of our \nSplashActivity\n we'll make sure we have all our data and launch a new Intent:\n\n\n// ...\n@Override\npublic void onSuccess(OddView view) {\n    OddApp oddApp = OddApp.getInstance();\n\n    if (getViewType().equals(HOME_VIEW)) {\n        oddApp.setHomeView(view);\n    } else if (getViewType().equals(MENU_VIEW)) {\n        oddApp.setMenuView(view);\n    }\n\n    if (oddApp.getHomeView() != null \n oddApp.getMenuView() != null) {\n        Intent home = new Intent(context, HomeActivity.class);\n        startActivity(home);\n    }\n}\n// ...", 
            "title": "Initialize API Calls"
        }, 
        {
            "location": "/initialize_api_calls/#get-config-data-from-api", 
            "text": "Now it's time to make our  SplashActivity  actually do somthing. First we'll set up the member variables...  // app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\npublic class SplashActivity extends AppCompatActivity {\n    // Constants\n    private static final String HOME_VIEW = \"homepage\";\n    private static final String MENU_VIEW = \"menu\";\n\n    // Data\n    private RestServiceProvider restServiceProvider = RestServiceProvider.getInstance();\n    private ApiCaller apiCaller = restServiceProvider.getApiCaller();\n\n    // ...\n}  There's a new class that we're interacting with called  ApiCaller . This does exactly what it sounds like and is the class used to make calls to the API.  The first thing we'll want to do in our  onCreate  method after setting the content view is set our context.  // app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;\n}\n// ...  The next thing check to see if the application is connected to the internet. This method may be useful in other classes in our application so instead of creating a method for it in our  SplashActivity  we'll create a  Utility  class with a method to check if there is internet connectivity.  package sample.oddworks.com.myoddworksapplication;\n\nimport android.content.Context;\nimport android.net.ConnectivityManager;\n\npublic class Utility {\n    public static boolean hasInternetConnection(Context context) {\n        ConnectivityManager con_manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n\n        if (con_manager.getActiveNetworkInfo() != null   con_manager.getActiveNetworkInfo().isAvailable()   con_manager.getActiveNetworkInfo().isConnected()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}  In order for this to work, we'll need to add some permissions to our  AndroidManifest  file right before the opening  application  tag.  // app/manifests/AndroidManifest.xml\n\n// ... uses-permission android:name=\"android.permission.INTERNET\" /  uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" / \n// ...  Now we can check to see if the app has connectivity in the  SplashActivity 's  onCreate  method:  // app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_splash);\n    context = this;\n\n    if (Utility.hasInternetConnection(getApplicationContext())) {\n        apiCaller.getConfig(new ConfigRequestCallback());\n    } else {\n        // handle failure by notifying user on UI\n        // consider giving them a \"retry\" button\n    }\n}\n\nprivate final class ConfigRequestCallback implements OddCallback Config  {\n    @Override\n    public void onSuccess(Config config) {\n        // handle success\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n}\n// ...  If the app is connected to the internet we use the  apiCaller  to request configuration from the API and pass it a callback class that implements an  OddCallback . If there's a failure we should notify the user of this and give them the option to retry.  Warning: if you try to manipulate the UI within this callback you will crash the application since you aren't running on the main thread. You must specify that you'd like to run on the main thread if you'd like to make any UI updates.", 
            "title": "Get Config Data from API"
        }, 
        {
            "location": "/initialize_api_calls/#getting-view-data-from-api", 
            "text": "Assuming the config request returns successful we can use the config object to set up many things about our app. For now, we'll only focus on the views that the config sends us.  // app/java/sample.oddworks.com.oddsampleapp/SplashActivity\n\n// ...\nprivate final class ConfigRequestCallback implements OddCallback Config  {\n    @Override\n    public void onSuccess(Config config) {\n        Map String, String  views = config.getViews();\n        String homeView = views.get(HOME_VIEW);\n        String menuView = views.get(MENU_VIEW);\n\n        apiCaller.getView(homeView, new ViewRequestCallback(HOME_VIEW));\n        apiCaller.getView(menuView, new ViewRequestCallback(MENU_VIEW));\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n}\n\nprivate final class ViewRequestCallback implements OddCallback OddView  {\n    private String mViewType;\n\n    public ViewRequestCallback(String viewType) {\n        mViewType = viewType;\n    }\n\n    @Override\n    public void onSuccess(OddView view) {\n        OddApp oddApp = OddApp.getInstance();\n\n        if (getViewType().equals(HOME_VIEW)) {\n            oddApp.setHomeView(view);\n        } else if (getViewType().equals(MENU_VIEW)) {\n            oddApp.setMenuView(view);\n        }\n    }\n\n    @Override\n    public void onFailure(final Exception exception) {\n        // handle failure\n    }\n\n    public String getViewType() {\n        return mViewType;\n    }\n}\n// ...  Here, we're creating a new  OddCallback  for the views that we're requesting through the  apiCaller . This callback accepts a  viewType  parameter that will determine which view we're setting in our  OddApp  instance. Remember, the setter metods for each view utilize the  OddStore  so we'll have access to this information throughout the app if the member variables in  OddApp  get leaked from memory.  The last thing we need to do in our  SplashActivity  is launch a new Activity that will make use of all the data we've fetched. First we'll need to create a new Activity, we'll call ours  HomeActivity . Now in the  ViewRequestCallback  section of our  SplashActivity  we'll make sure we have all our data and launch a new Intent:  // ...\n@Override\npublic void onSuccess(OddView view) {\n    OddApp oddApp = OddApp.getInstance();\n\n    if (getViewType().equals(HOME_VIEW)) {\n        oddApp.setHomeView(view);\n    } else if (getViewType().equals(MENU_VIEW)) {\n        oddApp.setMenuView(view);\n    }\n\n    if (oddApp.getHomeView() != null   oddApp.getMenuView() != null) {\n        Intent home = new Intent(context, HomeActivity.class);\n        startActivity(home);\n    }\n}\n// ...", 
            "title": "Getting View Data from API"
        }
    ]
}